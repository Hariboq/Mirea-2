📋 Оглавление
🎯 Введение

🏗️ Сравнение видов куч

📊 Сравнительная таблица операций

💻 Реализация на разных языках

👨‍💻 Примеры кода

🚀 Инструкция по GitHub

🎯 Введение
Данный проект представляет собой комплексное сравнение трёх основных структур данных - бинарной кучи, биномиальной кучи и хеш-таблиц - реализованных на трёх популярных языках программирования: Python, C++ и Java.

📁 Структура проекта
text
HeapHashComparison/
├── README.md
├── python/
│   ├── fibonacci.py
│   ├── binary_heap.py
│   └── hash_table.py
├── cpp/
│   ├── fibonacci.cpp
│   ├── binary_heap.cpp
│   └── hash_table.cpp
└── java/
    ├── Fibonacci.java
    ├── BinaryHeap.java
    └── HashTable.java
🏗️ Сравнение видов куч
🔷 Бинарная куча (Binary Heap)
📐 Структура: Полное бинарное дерево

✨ Свойства:

✅ Все уровни, кроме последнего, полностью заполнены

✅ Последний уровень заполняется слева направо

✅ Свойство кучи: родитель ≤ дети (min-heap) или родитель ≥ дети (max-heap)

👍 Преимущества:

🚀 Простая реализация

⚡ Эффективные базовые операции: O(log n) для вставки/удаления

💾 Эффективное хранение в массиве

👎 Недостатки:

❌ Не поддерживает эффективное слияние

❌ Ограниченная функциональность

🔶 Биномиальная куча (Binomial Heap)
📐 Структура: Набор биномиальных деревьев

✨ Свойства:

✅ Каждое биномиальное дерево порядка k имеет 2^k узлов

✅ Ключ вершины ≤ ключей её детей

✅ Деревья имеют разные порядки

👍 Преимущества:

🔄 Эффективное слияние: O(log n)

🎯 Более гибкая структура

🔧 Поддержка уменьшения ключа

👎 Недостатки:

⚠️ Более сложная реализация

⚠️ Большая константа в асимптотике

🔷 Куча Фибоначчи (Fibonacci Heap)
📐 Структура: Набор деревьев (не обязательно биномиальных)

👍 Преимущества:

⚡ Амортизированное O(1) для вставки и уменьшения ключа

⚡ O(log n) для извлечения минимума

🏆 Наилучшая асимптотика для алгоритма Дейкстры

👎 Недостатки:

⚠️ Сложная реализация

⚠️ Большие константы в реальном времени

📚 Теоретическая структура, редко используется на практике

📊 Сравнительная таблица операций
Операция	Бинарная куча	Биномиальная куча	Куча Фибоначчи
🎯 Вставка	O(log n)	O(log n)	O(1)*
📤 Извлечение минимума	O(log n)	O(log n)	O(log n)*
🔽 Уменьшение ключа	O(log n)	O(log n)	O(1)*
🔄 Слияние	O(n)	O(log n)	O(1)
🔍 Поиск минимума	O(1)	O(log n)	O(1)
Амортизированная сложность

💻 Реализация на разных языках
🐍 Python
🌟 Особенности:

Динамическая типизация

 Встроенные структуры данных (heapq, dict)

 Простота реализации

 Читаемый синтаксис

⚡ C++
 Особенности:

 Статическая типизация

 STL библиотека (priority_queue, unordered_map)

 Высокая производительность

 Контроль над памятью

☕ Java
 Особенности:

 Сборка мусора

 Богатая стандартная библиотека (PriorityQueue, HashMap)

🌐 Кроссплатформенность

🏢 Объектно-ориентированный подход
